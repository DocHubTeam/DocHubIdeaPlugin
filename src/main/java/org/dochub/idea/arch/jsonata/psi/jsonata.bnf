// Метаинформация
{
  // Название и расположение генерируемого класса парсера
  parserClass="org.dochub.idea.arch.jsonata.JSONataParser"
  // Ссылка на базовый класс, от которого будут наследоваться все PSI-элементы(узлы дерева).
  // обычно ASTWrapperPsiElement или его наследники.
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  //префикс классов и интерфейсов(обычно по имени языка) и
  //суффикс для реализации интерфейсов(как правило - Impl)
  psiClassPrefix="JSONata"
  psiImplClassSuffix="Impl"

  //пакет для интерфейсов и их реализаций.
  psiPackage="org.intellij.sdk.language.psi"
  psiImplPackage="org.intellij.sdk.language.psi.impl"

  // генерируемое хранилище всех типов элементов
  elementTypeHolderClass="org.dochub.idea.arch.jsonata.psi.JSONataTypes"
  // класс типов элементов (не генерируется, наследник IElementType)
  elementTypeClass="org.dochub.idea.arch.jsonata.psi.JSONataElementType"
  //класс для токенов
  tokenTypeClass="org.dochub.idea.arch.jsonata.psi.JSONataTokenType"
  //класс с набором статических методов, которые используются как имплементация требуемых методов для psi-элементов.
  psiImplUtilClass="org.intellij.sdk.language.psi.impl.JSONataPsiImplUtil"
}

// Грамматика языка

root ::= !<<eof>> jsonata

jsonata ::= topDecl (SEMICOLON topDecl)* SEMICOLON?

topDecl ::= block | statement

statement ::= defFunction | binding | expression

expression ::= expressionBase (binaryOperator expressionAdditional | filterExpr | ifThenElse)*

expressionBase ::= filterExpr | expressionAdditional

expressionAdditional ::= block | object | term

term ::= (LPARENTH expression RPARENTH) | useOfVariableOrFunction | STRING | REGEX | ID | numb | MUL // MUL is Wildcard here

binaryOperator ::= DOT | DOUBLE_DOT | PLUS | MINUS | MUL | QUOTIENT | REMAINDER | CONCAT | IN | EQ | NOT_EQ | GREATER | GREATER_OR_EQUAL | LESS | LESS_OR_EQUAL | OR | AND | CONTEXT

ifThenElse ::= QUESTION_MARK expression (COLON expression)?

filterExpr ::= LBRACKET filterBody? RBRACKET

filterBody ::= expression (COMMA expression)*

binding ::= VARIABLE ASSIGN statement

object ::= LBRACE objectBody? RBRACE

objectBody ::= objectStatement (COMMA objectStatement)*

objectStatement ::= topDecl COLON expression

block ::= LPARENTH blockBody RPARENTH

blockBody ::= blockStatement (SEMICOLON blockStatement)* SEMICOLON?

blockStatement ::= statement

numb ::= (MINUS)? NUMBER

useOfVariableOrFunction ::= VARIABLE useFunctionPart?

useFunctionPart ::= LPARENTH useFunctionArguments? RPARENTH

useFunctionArguments ::= useFunctionArg (COMMA useFunctionArg)*

useFunctionArg ::= expression

defFunction ::= FUNCTION LPARENTH defFunctionArguments? RPARENTH LBRACE defFunctionBody RBRACE

defFunctionArguments ::= VARIABLE (COMMA VARIABLE)*

defFunctionBody ::= expression

// TODO: delete after full support
all ::= LINE_COMMENT | SEMICOLON | ASSIGN | LBRACE | RBRACE | FUNCTION | STRING | ID | SYS_VARIABLE | ORDER_BY | LPARENTH | RPARENTH | DOT | POSITIONAL | CONTEXT | VARIABLE | VERTICAL_BAR | COMMA | CHAIN | PLUS | MINUS | QUOTIENT | REMAINDER | LBRACKET | DOUBLE_DOT | RBRACKET | EQ | NOT_EQ | GREATER | LESS | GREATER_OR_EQUAL | LESS_OR_EQUAL | IN | AND | OR | CONCAT | COLON | COMMENT | DOUBLE_QUOTE | BACKSLASH | QUOTE | BACKTICK | BOOLEAN | QUESTION_MARK | NUMBER | REGEX

unusedInBnf ::= COMMENT | NEW_LINE | DOUBLE_QUOTE | BACKSLASH | QUOTE | BACKTICK | BOOLEAN | QUESTION_MARK